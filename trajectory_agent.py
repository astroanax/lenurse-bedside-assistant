"""
VLA-Integrated Action Execution Module for Bedside Assistant
Handles execution of actions generated by the Vision-Language-Action model

The VLA model (pi0.5) generates actions from visual observations and language commands.
This module executes those actions on the SO-101 5 DOF robotic arm.

For reliability, the system can fall back to pre-computed action sequences
when VLA inference is unavailable or low-confidence.
"""

import os
import json
import time
import threading
from typing import Optional, Dict, List, Callable, Generator
from dataclasses import dataclass


# Robot Configuration from record_replay.py
HOME_POS = [
    2048,
    1628,
    1988,
    2856,
    2048,
    2048,
]  # [base, shoulder, elbow, wrist, wrist_rot, gripper]
SERVO_LIMITS = {
    1: [500, 3500],
    2: [500, 3500],
    3: [500, 3500],
    4: [500, 3500],
    5: [500, 3500],
    6: [500, 3500],
}


@dataclass
class TrajectoryPoint:
    """Single trajectory waypoint"""

    t: float  # Time from start (seconds)
    pos: List[int]  # [servo1, servo2, servo3, servo4, servo5, servo6]


@dataclass
class TrajectoryData:
    """Complete trajectory data"""

    name: str
    duration: float
    num_points: int
    points: List[TrajectoryPoint]

    @staticmethod
    def from_json(data: dict, name: str = "") -> "TrajectoryData":
        """Load from JSON dict"""
        points = [
            TrajectoryPoint(t=p["t"], pos=p["pos"]) for p in data.get("trajectory", [])
        ]
        return TrajectoryData(
            name=name,
            duration=data.get("duration", 0.0),
            num_points=len(points),
            points=points,
        )


class TrajectoryReplayer:
    """Replays pre-recorded robot trajectories"""

    TRAJECTORIES_DIR = "trajectories"
    SERVO_SPEED = 800
    SERVO_ACC = 40

    def __init__(self, servo_handler: Optional[Callable] = None):
        """
        Initialize trajectory replayer

        Args:
            servo_handler: Callback function to move servos
                          Expected signature: servo_handler(servo_id, position, speed, acc)
        """
        self.servo_handler = servo_handler
        self.current_trajectory: Optional[TrajectoryData] = None
        self.is_replaying = False
        self.replay_progress = 0.0  # 0.0 to 1.0
        self.last_error: Optional[str] = None
        self._lock = threading.Lock()
        self.on_complete_callback: Optional[Callable] = (
            None  # Callback when trajectory completes
        )

        # Create trajectories directory if it doesn't exist
        os.makedirs(self.TRAJECTORIES_DIR, exist_ok=True)

    def set_servo_handler(self, handler: Callable):
        """Set the servo control handler"""
        self.servo_handler = handler

    def set_on_complete_callback(self, callback: Optional[Callable]):
        """Set callback to be called when trajectory completes"""
        self.on_complete_callback = callback

    def list_trajectories(self) -> List[Dict]:
        """
        List all available trajectory files

        Returns:
            List of trajectory info dicts
        """
        trajectories = []
        try:
            if not os.path.exists(self.TRAJECTORIES_DIR):
                return trajectories

            for filename in os.listdir(self.TRAJECTORIES_DIR):
                if filename.endswith(".json"):
                    filepath = os.path.join(self.TRAJECTORIES_DIR, filename)
                    try:
                        with open(filepath, "r") as f:
                            data = json.load(f)

                        trajectories.append(
                            {
                                "filename": filename,
                                "name": data.get("name", filename.replace(".json", "")),
                                "duration": data.get("duration", 0.0),
                                "num_points": data.get(
                                    "num_points", len(data.get("trajectory", []))
                                ),
                            }
                        )
                    except (json.JSONDecodeError, IOError) as e:
                        print(f"Error reading trajectory {filename}: {e}")

        except Exception as e:
            print(f"Error listing trajectories: {e}")

        return sorted(trajectories, key=lambda x: x["filename"])

    def load_trajectory(self, filename: str) -> bool:
        """
        Load a trajectory from file

        Args:
            filename: Name of trajectory file in trajectories/ directory

        Returns:
            True if loaded successfully, False otherwise
        """
        filepath = os.path.join(self.TRAJECTORIES_DIR, filename)

        try:
            if not os.path.exists(filepath):
                self.last_error = f"Trajectory file not found: {filename}"
                print(f"Error: {self.last_error}")
                return False

            with open(filepath, "r") as f:
                data = json.load(f)

            self.current_trajectory = TrajectoryData.from_json(data, filename)
            self.last_error = None
            print(
                f"Loaded trajectory: {filename} ({self.current_trajectory.num_points} points)"
            )
            return True

        except json.JSONDecodeError as e:
            self.last_error = f"Invalid JSON in {filename}: {e}"
            print(f"Error: {self.last_error}")
            return False
        except Exception as e:
            self.last_error = f"Error loading trajectory: {e}"
            print(f"Error: {self.last_error}")
            return False

    def _generate_twist_trajectory(
        self, current_pos: List[int], angle_delta: int = 50
    ) -> TrajectoryData:
        """
        Generate a synthetic twist trajectory that rotates servo 5 (wrist_rot)
        by the specified angle within the inspection position

        Args:
            current_pos: Current arm position (from last pick trajectory)
            angle_delta: Degrees to rotate (default 50)

        Returns:
            TrajectoryData for the twist motion
        """
        # Create waypoints for smooth rotation
        # From current position -> rotate servo 5 -> back to current position
        duration = 2.0  # 2 second twist motion
        num_points = 20

        points = []
        for i in range(num_points):
            t = (i / (num_points - 1)) * duration
            progress = i / (num_points - 1)

            # Smooth motion: 0 -> 1 -> 0 (triangular wave)
            if progress < 0.5:
                wave = progress * 2  # 0 to 1 in first half
            else:
                wave = (1 - progress) * 2  # 1 to 0 in second half

            # Rotate servo 5 by angle_delta
            servo5_offset = int(
                angle_delta * 5.68 * wave
            )  # Convert degrees to servo units
            servo5_target = max(
                SERVO_LIMITS[5][0],
                min(SERVO_LIMITS[5][1], current_pos[4] + servo5_offset),
            )

            pos = current_pos.copy()
            pos[4] = servo5_target  # Update servo 5 (wrist rotation)

            points.append(TrajectoryPoint(t=t, pos=pos))

        return TrajectoryData(
            name="twist",
            duration=duration,
            num_points=len(points),
            points=points,
        )

    def _generate_drop_trajectory(self) -> TrajectoryData:
        """
        Generate a synthetic drop/place trajectory that returns arm to home position

        Returns:
            TrajectoryData for returning to home
        """
        # Smooth motion from current position back to HOME_POS
        duration = 3.0  # 3 seconds for smooth return
        num_points = 30

        # Use current trajectory's final position as start
        start_pos = (
            self.current_trajectory.points[-1].pos
            if self.current_trajectory and self.current_trajectory.points
            else HOME_POS
        )

        points = []
        for i in range(num_points):
            t = (i / (num_points - 1)) * duration
            progress = i / (num_points - 1)

            # Linear interpolation from current position to HOME_POS
            pos = [
                int(start_pos[j] + (HOME_POS[j] - start_pos[j]) * progress)
                for j in range(6)
            ]

            points.append(TrajectoryPoint(t=t, pos=pos))

        return TrajectoryData(
            name="drop",
            duration=duration,
            num_points=len(points),
            points=points,
        )

    def _generate_greet_trajectory(self) -> TrajectoryData:
        """
        Generate a greeting trajectory:
        1. Move to home position
        2. Open and close gripper (snap) multiple times

        Returns:
            TrajectoryData for greeting gesture
        """
        duration = 4.0  # 4 seconds total
        num_points = 40

        # Start from current position or HOME_POS
        start_pos = (
            self.current_trajectory.points[-1].pos
            if self.current_trajectory and self.current_trajectory.points
            else HOME_POS
        )

        points = []

        # Phase 1: Move to home (0-2 seconds, first 20 points)
        for i in range(20):
            t = (i / 19) * 2.0
            progress = i / 19

            # Linear interpolation to HOME_POS
            pos = [
                int(start_pos[j] + (HOME_POS[j] - start_pos[j]) * progress)
                for j in range(6)
            ]
            points.append(TrajectoryPoint(t=t, pos=pos))

        # Phase 2: Open/close gripper 3 times (2-4 seconds, next 20 points)
        gripper_open = 2500  # Open position for servo 6
        gripper_close = 1500  # Close position for servo 6

        for i in range(20):
            t = 2.0 + (i / 19) * 2.0
            # Create a wave pattern: 0 -> 1 -> 0 -> 1 -> 0 -> 1 -> 0 (3 snaps)
            wave = abs(((i / 19) * 6) % 2 - 1)  # Triangular wave

            gripper_pos = int(gripper_close + (gripper_open - gripper_close) * wave)

            pos = HOME_POS.copy()
            pos[5] = gripper_pos  # Servo 6 (gripper)
            points.append(TrajectoryPoint(t=t, pos=pos))

        return TrajectoryData(
            name="greet",
            duration=duration,
            num_points=len(points),
            points=points,
        )

    def replay(
        self, filename: Optional[str] = None, on_progress: Optional[Callable] = None
    ) -> bool:
        """
        Replay a trajectory

        Args:
            filename: Trajectory file to load and replay. If None, uses current_trajectory
                     Special cases: "twist", "drop", or "greet" for synthetic trajectories
            on_progress: Callback for progress updates (called with progress 0.0-1.0)

        Returns:
            True if replay completed successfully
        """
        # Handle special synthetic trajectories
        if filename == "twist":
            if not self.current_trajectory or not self.current_trajectory.points:
                self.last_error = "No position to twist from (pick a component first)"
                return False
            current_pos = self.current_trajectory.points[-1].pos
            self.current_trajectory = self._generate_twist_trajectory(current_pos)
        elif filename == "drop":
            self.current_trajectory = self._generate_drop_trajectory()
        elif filename == "greet":
            self.current_trajectory = self._generate_greet_trajectory()
        elif filename:
            # Load trajectory from file
            if not self.load_trajectory(filename):
                return False
        elif not self.current_trajectory:
            self.last_error = "No trajectory loaded"
            return False

        if not self.servo_handler:
            self.last_error = "No servo handler set"
            return False

        # Start replay in background thread
        thread = threading.Thread(
            target=self._replay_worker, args=(on_progress,), daemon=True
        )
        thread.start()
        return True

    def _replay_worker(self, on_progress: Optional[Callable] = None):
        """Worker thread for trajectory replay"""
        with self._lock:
            if self.is_replaying:
                return
            self.is_replaying = True
            self.replay_progress = 0.0

        try:
            trajectory = self.current_trajectory
            if not trajectory or not trajectory.points:
                self.last_error = "No trajectory points to replay"
                return

            start_time = time.time()
            print(f"Starting trajectory replay: {trajectory.name}")
            print(
                f"Duration: {trajectory.duration:.2f}s, Points: {trajectory.num_points}"
            )

            for i, point in enumerate(trajectory.points):
                # Calculate target time
                target_time = point.t

                # Wait until we should execute this point
                while time.time() - start_time < target_time:
                    time.sleep(0.005)

                # Move servos
                self._move_all_servos(point.pos)

                # Update progress
                with self._lock:
                    self.replay_progress = (i + 1) / trajectory.num_points

                if on_progress:
                    on_progress(self.replay_progress)

                print(
                    f"Point {i + 1}/{trajectory.num_points}: t={target_time:.2f}s",
                    end="\r",
                )

            print(f"\nTrajectory replay complete!")
            self.last_error = None

            # Call completion callback if set
            if self.on_complete_callback:
                try:
                    self.on_complete_callback()
                except Exception as e:
                    print(f"Error in completion callback: {e}")

        except Exception as e:
            self.last_error = f"Replay error: {e}"
            print(f"Error during replay: {e}")

        finally:
            with self._lock:
                self.is_replaying = False
                self.replay_progress = 1.0 if self.last_error is None else 0.0

    def _move_all_servos(self, positions: List[int]):
        """Move all servos to target positions"""
        if not self.servo_handler:
            return

        try:
            for servo_id, position in enumerate(positions, start=1):
                # Call servo handler with servo_id, position, speed, acc
                self.servo_handler(servo_id, position, self.SERVO_SPEED, self.SERVO_ACC)
                time.sleep(0.01)  # Small delay between servo commands
        except Exception as e:
            print(f"Error moving servos: {e}")

    def stop_replay(self):
        """Stop current replay"""
        with self._lock:
            self.is_replaying = False

    def get_status(self) -> Dict:
        """Get current replay status"""
        with self._lock:
            return {
                "is_replaying": self.is_replaying,
                "progress": self.replay_progress,
                "current_trajectory": self.current_trajectory.name
                if self.current_trajectory
                else None,
                "error": self.last_error,
            }


# Singleton instance
_replayer_instance: Optional[TrajectoryReplayer] = None


def get_replayer() -> TrajectoryReplayer:
    """Get or create singleton trajectory replayer"""
    global _replayer_instance
    if _replayer_instance is None:
        _replayer_instance = TrajectoryReplayer()
    return _replayer_instance
